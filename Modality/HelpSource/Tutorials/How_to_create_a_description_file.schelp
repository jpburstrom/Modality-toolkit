title:: How to create a description file
summary:: How to create a description file to use with the Modality toolkit.
categories:: Libraries>Modality
related:: Overviews/Modality, Classes/MKtl, Reference/MKtl_description_files, Classes/MIDIExplorer, Classes/HIDExplorer, Reference/Naming_conventions_in_element_descriptions

Section:: Introduction

The functionality of link::Classes/MKtl:: relies on descriptions of the used devices. For some Controllers, there are already descriptions available, chances are that your device is not among them.

There are three tutorials that explain the procedure for the three different protocols. This tutorial describes elements that can be part of any description file (regardless of protocol).

list::
##link::Tutorials/How_to_create_a_description_file_for_MIDI::
##link::Tutorials/How_to_create_a_description_file_for_HID::
##link::Tutorials/How_to_create_a_description_file_for_OSC::
::

section:: Basic structure of the description file

The description file is a Dictionary with a number of required entries.

The main entry is the code::description:: which contains all the elements/controls of a device.

For physical devices, you need to define the protocol and the idInfo. The code::protocol:: is one of code::\osc, \midi, \hid::. The code::idInfo:: is different per protocol, check the respective tutorial for an elaborate description.

If you want to create a virtual device, the minimum info required is the idInfo and protocol: code::(idInfo: \something, protocol: \virtual):: and in the description, every element needs an ioType and a spec.

For example:

code::
(
m = MKtl.new(
	\oneButton,
	(
		idInfo: \oneBut,
		protocol: \virtual,
		elementsDesc: (
			elements: [
				(key: \bt, type: \button, ioType: \in, \spec: \but )
			]
		)
	),
	false );
);

m.gui;    //
m.elAt;   // the elementGroup
m.elAt(0); // the only element in it
m.elAt(\bt); // the only element in it
m.free; // free m's resources and remove it from MKtl.all
::

For an MKtl with 4 buttons, one can write the elementsDesc in multiple ways:

code::
// 1. write out every element fully:
(
// ...
elementsDesc: (
	elements: [
		(key: \bt1, type: \button, ioType: \in, \spec: \but ),
		(key: \bt2, type: \button, ioType: \in, \spec: \but ),
		(key: \bt3, type: \button, ioType: \in, \spec: \but )
		(key: \bt4, type: \button, ioType: \in, \spec: \but )
	]
)
);

// 2. put all shared properties in the entry 'shared':
elementsDesc: (
	shared: (elementType: \button, ioType: \in, \spec: \but ),
	elements: [
		(key: \bt_1),
		(key: \bt_2),
		(key: \bt_3),
		(key: \bt_4)
	]
)

// 3. generate the elements by code -
// this may seem complicated for 3-4 elements, but useful for more
(
	key: \bt,
	shared: (elementType: \button, ioType: \in, \spec: \but ),
elements: (1..4).collect { |i| (key: ("bt_" ++i).asSymbol) }
)


(
m = MKtl.new(
	\threeButtons,
	(
		idInfo: \oneBut,
		protocol: \virtual,
		elementsDesc: (
			key: \bt,
			shared: (elementType: \button, ioType: \in, \spec: \but ),
			elements: (1..4).collect { |i| (key: ("bt_" ++i).asSymbol) }
		)
	),
	false );
);
m.postElements;

::

See also: link::Reference/MKtl_description_files:: for the complete description of all possible keys.

section:: Specs

If a control of your device needs a custom Spec, then you can define this in the element code::spec:: of the device description.

For example:

code::
specs: (
	mantaTouch: [ 0, 227 ].asSpec,
	mantaSlider: [ 0, 4095 ].asSpec,
	mantaLed: ItemsSpec.new( ["off","amber","red"] ), // led can be off, amber or red
)
::

Many common specs in SC are in Spec.specs, and some specs that many MKtls share can be found in MKtl.specs:
code::
Spec.specs.keys;	// get the names
MKtl.globalSpecs.keys;
MKtl.getSpec( \hidHat ); // look up a specific one
::

section:: Elements


Elements require a type describing which kind of physical thing it is,
such as button, slider, joyAxis, mouseWheel, or any of:

code::MKtlElement.types::

For multiple elements, one can make groups, which is helpful for semantic clarity.

For example, an MKtl with 5 sliders and 4 buttons, and two labeled buttons (play and stop) would look like this:

code::
(
m = MKtl.new( \sliders_knobs, (
	idInfo: \ex,
	protocol: \virtual,
	elementsDesc: (
		elements: [
			(
				key: \sl,
				shared: ( elementType: \slider, ioType: \in, \spec: \midiCC ),
				elements: (1..5).collect { |i| (key: i.asSymbol) }),
			(
				key: \bt,
				shared: ( elementType: \button, ioType: \in, \spec: \but ),
				elements: (1..4).collect { |i| (key: i.asSymbol) }),
			(
				key: \play,
				elementType: \button, ioType: \in, \spec: \but ),
			(
				key: \stop, elementType: \button, ioType: \in, \spec: \but )
		]
	)
), false );
);
m.gui;
m.elAt(\sl, 0).elemDesc;
m.elAt(\sl, \1);

// you can access the elements by hierarchical names:
m.elAt(\play)
m.elAt(\stop).value_(1)
m.elAt(\bt)  // the group of 5 buttons
m.elAt(\bt, 0).value_(1)  // one of them
m.elAt(\sl).do(_.value_(1.0.rand))  // all sliders

// one can als access them by direct names:

m.dictAt(\sl_1).action = { |sl| "yo slider: % > %\n".postf(sl.name, sl.value) };
m.elAt(\sl, 0).valueAction_(1.0.rand);

m.free; // free m's resources and remove it from MKtl.all
::

For full details on single element description see also:
link::Reference/Naming_conventions_in_element_descriptions::


section:: Finding descriptions for similar devices

Many devices already hace description files, which are used by the link::Classes/MKtlDesc:: class. They can be found here:
code::
MKtlDesc.openFolder;
::
You are cordially invited to contribute desc files for any devices you have and find useful!
For details on making descs for devices using MIDI, HID, or OSC, please read on here:

list::
##link::Tutorials/How_to_create_a_description_file_for_MIDI::
##link::Tutorials/How_to_create_a_description_file_for_HID::
##link::Tutorials/How_to_create_a_description_file_for_OSC::
::
