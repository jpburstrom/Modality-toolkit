title:: How to create a description file for a MIDI device
summary:: How to create a description file to use with the Modality toolkit for a MIDI device
categories:: Libraries>Modality
related:: Overviews/Modality, Classes/MKtl, Reference/MKtl_description_files, Classes/MIDIExplorer, Classes/HIDExplorer, Tutorials/How_to_create_a_description_file


MIDIClient.init;

Section:: Introduction

The functionality of link::Classes/MKtl:: relies on descriptions of the used devices. For some Controllers, there are already descriptions available, chances are that your device is not among them.

This Tutorial first shows simple examples of MIDI interfaces, by emulating them within SuperCollider, and then describes how to create a description file for your interface.


list::
##link::#Simple input::
##link::#Simple output::
##link::#Explore a MIDI device::
##link::#Write a description file for the explored MIDI device::
##link::#MIDI output::
##link::#MIDI device info::
##link::#MIDI Initialisation messages::
::

section:: Simple input

In this section we will go through all the different types of MIDI messages that may come in and show how to write a description for that element.

There are a number of different types of MIDI messages: code::noteOn:: and code::noteOff:: for midi note messages - typically connected to a MIDI keyboard, pitch bend messages, after touch messages, MIDI control messages (e.g. volume control) and MIDI program change messages (e.g. to switch to a different bank of sounds).

So you can test the examples below even without a physical device, we will use SuperCollider own input and output. In order to do that, you will need to do different things depending on which platform you are using. On OSX, please go to Audio MIDI Setup, and create an IAC Bus you can use.

Some startup code for our next examples:

code::
// find all MIDI devices (and do MIDI initialisation)
MKtl.find(\midi);

// On OSX, this should now show something like this:
MIDI Sources:
	MIDIEndPoint("IAC Driver", "IAC Bus 1", -476939297)
MIDI Destinations:
	MIDIEndPoint("IAC Driver", "IAC Bus 1", -1608967985)

-----------------------------------------------------

// Available MIDIMKtls:
// MKtl(name, filename);  // *[ midi device, portname, uid]

MKtl('midi_0_iac_driver', 'midi_0_iac_driver');		// [ "IAC Driver", "IAC Bus 1", -476939297 ]

-----------------------------------------------------

::

Then you can continue here:

code::
(
// make a MIDIOut for the tests in the examples
Platform.case(
	\linux, {
		~midiOut= MIDIOut(0); // = SC's first midi output
		~midiOut.connect(1); // = connect to SC's first midi input
	},
	\osx, {
		// take the first endpoint in MIDIClient.destinations
		~midiOut = MIDIOut(0);
	}
	/*,
	\windows, {
		// please let us know what this should be!
	}
	*/
);

// and create proper idInfo for your platform
~idInfo = Platform.case(
	\linux, ( name: "SuperCollider", sourcePortIndex: 0 ),
	\osx, "IAC Driver",
	\windows, "no idea, please tell us what this should be!"
).postcs;

);
::

For information on MIDIOut see also:

link::Classes/MIDIOut#Linux specific: Connecting and disconnecting ports::

link::Classes/MIDIOut#OS X specific: Sending MIDI to other applications::


subsection:: MIDI note messages

MIDI note messages were originally designed for piano keys on a MIDI keyboard. But in many MIDI controllers they can also be connected to other buttons or drum pads. MIDI code::noteOn:: messages have a note number defining which key was pressed, and a velocity value defining the speed or intensity with which it was pressed (a typical mapping for this would be to make a sound louder when the key is pressed with a higher speed). When the note is released, a code::noteOff:: message is sent, again with a note number and a velocity (the speed of release, this could e.g. be mapped to the release time of an envelope). However, some MIDI devices also just sent a MIDI code::noteOn:: message with velocity zero when a note is released.

NOTE::
In SuperCollider MIDI noteOn messages with velocity 0 are always parsed as noteOff messages.
There is a pull request to SuperCollider for this, which makes this an option rather than a default:
code::
MIDIIn.noteOnZeroAsNoteOff = false;
::
See: link::https://github.com/supercollider/supercollider/issues/1483::
and: link::https://github.com/supercollider/supercollider/pull/1488::
::


As a first example, here is how to create an element that responds to a code::noteOn:: event. For the velocity we use the code::spec: \midiVel::, which maps the range of 0 to 127 to the range between 0 and 1.

code::
// midiMsgType: \noteOn, one note
(
~descInput = (
	idInfo: ~idInfo,
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: \pkey,
				type: 'pianoKey',
				midiMsgType: \noteOn,
				midiChan: 0,
				midiNum: 64, // note number
				spec: \midiVel,
				ioType: \in
			)
		]
	)
)
);

// on OSX, does not work yet to build a proper device like this
MKtlLookup.all;
m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // later, one can update it
m.gui;
m.trace;
m.free;

// send some messages from MIDIOut,
// which come back in as if from an external device:
~midiOut.noteOn(0, 64, 127 );
~midiOut.noteOn(0, 64, 24 );
// this may not post anything - see note about noteOn and velocity zero
~midiOut.noteOn(0, 64, 0 );
::


As a second example, we show how to make an element that responds to a code::noteOff:: message:

code::
// midiMsgType: \noteOff,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: \pkey,
				type: 'pianoKey',
				midiMsgType: \noteOff,
				midiChan: 0,
				midiNum: 64, // note number
				spec: \midiVel,
				ioType: \in
			)
		]
	)
)
);
m.free;  // free m and make it new:
m = MKtl( \testMIDI, ~descInput );
// or rebuild it from the new description:
m.rebuild( ~descInput );
m.trace;

// make some messages:
~midiOut.noteOff(0, 64, 127 );
~midiOut.noteOff(0, 64, 24 );
~midiOut.noteOff(0, 64, 0 );
~midiOut.noteOn(0, 64, 0 );
::

In the case the velocity information is not so important or the code::noteOn:: message with velocity zero is automatically translated to zero, then you can also use the combined code::midiMsgType: \noteOnOff::, which will listen to either kind of message.
For example a simple button may just send a code::noteOn:: message with velocity 127 and a code::noteOff:: message with velocity 0. In that case it is useful to respond to both types of message with the same element. In the example we use the code::spec: \midiBut::.

code::
// midiMsgType: \noteOnOff,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: \bt,
				type: 'button',
				midiMsgType: \noteOnOff,
				midiChan: 0,
				midiNum: 64, // note number
				spec: \midiBut,
				ioType: \in
			)
		]
	)
);
)

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it
m.gui;
m.trace;

// make some messages:
~midiOut.noteOn(0, 64, 127 );
~midiOut.noteOn(0, 64, 0 ); // creates a noteOff message (see note)
~midiOut.noteOff(0, 64, 0 );

// note that we can see in the trace whether it was noteOn or noteOff:
~midiOut.noteOn(0, 64, 37 );
~midiOut.noteOff(0, 64, 37 );

// in the single element action, we cannot distinguish
// between the two message types:
m.trace(false);
m.elAt(\bt).action = { |el| el.postln };

// when we are not using the velocity as release velocity,
// (as is the case with buttons), we can distinguish them by value:
m.elAt(\bt).action = { |el|
	if(el.value > 0) {
		"on".postln;
	} {
		"off".postln;
	}
};

~midiOut.noteOn(0, 64, 127 );
~midiOut.noteOn(0, 64, 0 ); // creates a noteOff message (see note)
~midiOut.noteOff(0, 64, 0 );


To get noteOn and noteOff actions separately, one can make separate elements, and here one can declare shared properties for both elements.

(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: \bt,
				shared: (
					type: 'button',
					midiChan: 0,
					midiNum: 64,
					spec: \midiBut,
					ioType: \in
				),
				elements: [
					( key: \on, midiMsgType: \noteOn ),
					( key: \off, midiMsgType: \noteOff )
				]
			)
		]
	)
)
);
m.rebuild(~descInput);
m.elAt(\bt, \on).action = { "ON".postln };
m.elAt(\bt, \off).action = { "OFFFFF".postln };

~midiOut.noteOn(0, 64, 37 );
~midiOut.noteOff(0, 64, 37 );

::


subsection:: MIDI control messages

MIDI control messages are typically sent out by knobs, sliders or pedals on a device, but in some cases also buttons or built-in sensors.

code::
// midiMsgType: \cc - knob
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'kn',
				type: 'knob',
				midiMsgType: \cc,
				midiChan: 0,
				midiNum: 8, // control number
				spec: \midiCC,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it

m.trace;

// make some messages:
~midiOut.control(0, 8, 127 );
~midiOut.control(0, 8, 24 );
~midiOut.control(0, 8, 0 );
::

code::
// midiMsgType: \cc - button
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bt',
				type: 'button',
				midiMsgType: \cc,
				midiChan: 0,
				midiNum: 8, // control number
				spec: \midiBut,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it

m.trace;

// make some messages:
~midiOut.control(0, 8, 127 );
~midiOut.control(0, 8, 0 );
::

subsection:: MIDI pitch bend messages


MIDI pitch bend messages are sent out by MIDI keyboards - usually a control in the shape of a wheel that flips back to its center position left of the keyboard.
On some of the mini keyboards that you can find, the pitch bend message is implemented via buttons on the device in the same location.

code::
// midiMsgType: \bend,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bend',
				type: 'bender',
				midiMsgType: \bend, // bend needs midiChan only
				midiChan: 0,
				spec: \midiBend,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it
m.trace;

// make some messages:
~midiOut.bend(0, 128*128-1 ); // 14-bit value
~midiOut.bend(0, 128*64 );
~midiOut.bend(0, 0 );
::

subsection:: MIDI aftertouch messages


Aftertouch is the pressure that is on a piano key after the initial pressing (which is translated to note velocity as explained above). The MIDI protocol implements aftertouch in two ways:

Aftertouch, also called channel pressure, has a single aftertouch value per midi channel, which is usually applied to all notes playing on that channel. Tis is the more common touch implementation in hardware controllers. In SC, this is called code::\touch::.

PolyTouch, or polyphonic aftertouch,  allows an individual aftertouch value for every currently playing note. In SC, this is called code::\polyTouch::.

code::
// midiMsgType: \polyTouch,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'polyTouch',
				type: 'polyTouch',
				midiMsgType: \polyTouch,
				midiChan: 0,
				midiNum: 2, // polyTouch has a note number it applies to
				spec: \midiTouch,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it
m.trace;

// make some messages:
~midiOut.polyTouch(0, 2, 127 );
~midiOut.polyTouch( 0, 2, 63 );
~midiOut.polyTouch(0, 2, 0 );
::

code::
// midiMsgType: \touch,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'touch',
				type: 'touch',
				midiMsgType: \touch,
				// touch only has \midiChan, no \midiNum
				midiChan: 0,
				spec: \midiTouch,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it
m.trace;

// make some messages:
~midiOut.touch(0, 127 );
~midiOut.touch(0, 63 );
~midiOut.touch(0, 0 );
::

subsection:: MIDI program change messages

MIDI program change messages are typically sent when a device is changing the patch that is played on the synthesizer. They can be implemented by buttons, or knobs.

code::
// midiMsgType: \program,
(
~descInput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'prog',
				type: 'knob',
				midiMsgType: \program, // program does not need \midiNum
				midiChan: 0,
				spec: \midiProgram,
				ioType: \in
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descInput );
m.rebuild( ~descInput ); // updating it
m.trace;

// make some messages:
~midiOut.program(0, 127 );
~midiOut.program(0, 63 );
~midiOut.program(0, 0 );
::


section:: Simple output

In this section we will go through all the different types of MIDI messages that may be sent out and show how to write a description for that element.

Typical use of MIDI output on controllers would be controlling the LEDs on the device that indicate the current mode of the instrument that you are building, or telling motorized faders the values/positions they should move to.

But you could also create an MKtl that connects to a hardware synthesizer - or another software program, and use the Modality toolkit to send the control messages to it.

Which MIDI messages a controller reacts to can be found out from the controller's manual. Alternatively, you could just send it a bunch of different messages and see what happens. Apart from system exclusive messages, this should be safe to do - system exclusive messages can be used for uploading new firmware or changing firmware mode, so don't just experiment with that, without properly informing yourself first.

subsection:: MIDI note messages


code::
// midiMsgType: \noteOn
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bt',
				type: 'button',
				midiMsgType: \noteOn,
				midiChan: 0,
				midiNum: 2,
				spec: \midiVel,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

// turn on tracing of midi input, so we see incoming messages
MIDIFunc.trace

m.elAt( \bt ).value_( 0 ); // see note above on noteOn message with velocity zero; may show up in the trace as a noteOff
m.elAt( \bt ).value_( 1 );

m.gui; // and press the button for it
::


code::
// midiMsgType: \noteOff
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bt',
				type: 'button',
				midiMsgType: \noteOff,
				midiChan: 0,
				midiNum: 2,
				spec: \midiVel,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \bt ).value_( 0 );
m.elAt( \bt ).value_( 1 );

m.gui; // and press the button
::

subsection:: MIDI control messages

code::
// midiMsgType: \cc - slider
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'sl',
				type: 'slider',
				midiMsgType: \cc,
				midiChan: 0,
				midiNum: 2,
				spec: \midiCC,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \sl ).value_( 0 );
m.elAt( \sl ).value_( 0.4 );
m.elAt( \sl ).value_( 1 );

m.gui; // and move the slider
::

code::
// midiMsgType: \cc - slider
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bt',

				type: 'button',
				midiMsgType: \cc,
				midiChan: 0,
				midiNum: 2,
				spec: \midiBut,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \bt ).value_( 0 );
m.elAt( \bt ).value_( 1 );

m.gui; // and press the button
::


subsection:: MIDI pitch bend messages

code::
// midiMsgType: \bend
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'bend',
				type: 'slider',
				midiMsgType: \bend, // bend has no midiNum
				midiChan: 0,
				spec: \midiBend,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \bend ).value_( 0 );
m.elAt( \bend ).value_( 0.4 );
m.elAt( \bend ).value_( 1 );
m.elAt( \bend ).value_( 0.5 ); // default
::

subsection:: MIDI after touch messages

code::
// midiMsgType: \polyTouch
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'touch',
				type: 'slider',
				midiMsgType: \polyTouch,
				midiChan: 0,
				midiNum: 2,
				spec: \midiTouch,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \touch ).value_( 0 );
m.elAt( \touch ).value_( 0.4 );
m.elAt( \touch ).value_( 1 );
::

code::
// midiMsgType: \touch
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'touch',
				type: 'slider',
				midiMsgType: \touch, // touch does not need \midiNum
				midiChan: 0,
				spec: \midiTouch,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \touch ).value_( 0 );
m.elAt( \touch ).value_( 0.4 );
m.elAt( \touch ).value_( 1 );
::

subsection:: MIDI program change messages


code::
// midiMsgType: \program,
MIDIIn.connectAll; MIDIFunc.trace;
(
~descOutput = (
	idInfo: ~idInfo, // still around from above
	protocol: \midi,
	elementsDesc: (
		elements: [
			(
				key: 'prog',
				type: 'slider',
				midiMsgType: \program, // program does not need \midiNum
				midiChan: 0,
				spec: \midiProgram,
				ioType: \out
			)
		]
	)
)
);

m = MKtl( \testMIDI, ~descOutput );
m.rebuild( ~descOutput ); // updating it

m.elAt( \prog ).deviceValue_( 0 );
m.elAt( \prog ).deviceValue_( 64 );
m.elAt( \prog ).deviceValue_( 127 );
::

subsection:: MIDI system exclusive messages

note:: To be documented when fully implemented and tested.::

section:: Explore a MIDI device

note:: To be updated using the MIDIMonitor class when finished! ::

First, find your device in the list posted by the following code and assign the MKtl to a variable.
code::
MKtl.find;
// copy and change '' to the shortname of your device, e.g.
a = MKtl('iac', 'midi_0_iac_driver');

::

Now, turn on the explore mode and move every element on your controller. Make sure to go through all of them and move them in all their degrees of freedom.

code::
// MIDI: if you want more information on what is happening, turn on verbose mode:
MIDIExplorer.verbose = true;
MIDIExplorer.verbose = false; // turn it off again
::

When done, create a raw description file which you will edit and review in the next step.

code::
a.createDescriptionFile;
// and stop the exploring:
a.explore( false );
::

note::If this does not work for you, try: code::MIDIExplorer.compile:: and copy the code from the post window manually to a new file.::

section:: Reviewing the exploration

We now have a file that contains all of the raw data that we need for our description file. However, before we can use it in Modality, we will first need to review the data and make sure that the different functions of the controller are properly named.

subsection:: Build a description file from the raw data

The examples below are written for a MIDI device, but the same steps need to be taken for HID or other devices.

So first there is a bit of bookkeeping to be done.
The file we opened earlier contains lines such as:

code::
'_elName_0_005_': ('midiType': 'noteOn', 'type': 'pianoKey', 'chan': 0, 'midiNote':  5, 'spec': 'midiNote'),
::


To bring these into a form useable as a description file for Modality, we have to put it into the format specified in link::Reference/MKtl_description_files:::

code::
(
\identifier: (key: value, key: value, ... ),
\identifier: (key: value, key: value, ... ),

\groupIdentifier: [
	(key: value, key: value, ... ),
	(key: value, key: value, ... ),
	(key: value, key: value, ... ),
]
)
::

note::Naming conventions apply. You can find them at link::Reference/MKtl_description_files#Naming Conventions::.
::

Edit the code::edit and save me.desc.scd:: document to assemble your new description file. Make sure you pay attention to the following points:

Unless it does not make sense from the controller's layout (e.g. for record buttons as opposed to a collection of similar elements such as sliders), elements of the same type should be grouped into a hierarchical description for maximum compatibility.

Also, make sure to fill in appropriate descriptions for code::\type:: fields.


We here exemplify the process at hand of the following raw data, as it could possibly fall out from the code::MKtl().explore:: function mentioned above.
It contains information of a device with three knobs:

code::
(
	// ------ cc -------------
	'_elName_0_002_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  2,'spec': 'midiCC'),
	'_elName_0_003_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  3,'spec': 'midiCC'),
	'_elName_0_004_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  4,'spec': 'midiCC'),
);
::

NOTE::Although the type should be code::\knob::, it registers as code::\slider::. This is because only a cc value is coming in, and it does not state what kind of hardware element is producing it.
::

Edit the raw data and add it to a group:

code::
(
	// ------ cc -------------
	'kn': [
		('midiMsgType': 'cc', 'type': 'knob', 'midiChan': 0, 'midiNum':  2,'spec': 'midiCC'),
		('midiMsgType': 'cc', 'type': 'knob', 'midiChan': 0, 'midiNum':  3,'spec': 'midiCC'),
		('midiMsgType': 'cc', 'type': 'knob', 'midiChan': 0, 'midiNum':  4,'spec': 'midiCC')
	]
)
::

In case, the controller has banks of groups, the hierarchical structure would look like this:

code::
// raw data of two by three sliders
(
	// ------ cc -------------
	'_elName_0_002_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  2,'spec': 'midiCC'),
	'_elName_0_003_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  3,'spec': 'midiCC'),
	'_elName_0_004_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  4,'spec': 'midiCC'),
	'_elName_0_005_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  5,'spec': 'midiCC'),
	'_elName_0_006_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  6,'spec': 'midiCC'),
	'_elName_0_008_': ('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  8,'spec': 'midiCC'),
);
::




code::
(
	sl: [
		[ // bank 0
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  2,'spec': 'midiCC'),
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  3,'spec': 'midiCC'),
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  4,'spec': 'midiCC'),
		], [ // bank 1
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  5,'spec': 'midiCC'),
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  6,'spec': 'midiCC'),
			('midiMsgType': 'cc', 'type': 'slider', 'midiChan': 0, 'midiNum':  8,'spec': 'midiCC')
		]
	]
);
::

If a flat description for an element is required, it can be directly copied from the generated description skeleton. However, each element has to have a name that represents its functionality.

note::
You may want to restart the explore mode for this by evaluating
code::e.start.verbose_(true)::::

note::
Its also possible to create a description file without an actual device being attached. As long as you keep the naming conventions in mind you will be able to create a working GUI version.
::
note::
A proper description on how to combine code::\noteOn, \noteOff, \polyTouch:: is still missing in this tutorial. While the developer team is working on it, have a look at similar description files. You can find them in the folder opening when you evaluate
code::
MKtlDesc.openFolder;
::

::

note::
When exploring a MIDI device only the incoming MIDI is analysed. You will have to add the MIDI output elements manually. You will have to look up in the manual of your device or online to find out which MIDI messages your device responds to.
::

subsection:: Save description file and test it

If you are happy with the generated document, save it with a meaningful name to the descriptions folder. You can open it with
code::
MKtl.openDescriptionFolder;
::
The filename should give a meaningful hint to the device it is made for. It further needs to end in code::".desc.scd"::.

To test your description file, restart SuperCollider and follow instructions in link::Tutorials/ModalityTutorial::.
/// ... To be updated using the MIDIMonitor class when finished ... ///



section:: MIDI device info

In the simple case, your MIDI device creates a single MIDI source port, by which it sends MIDI to the computer, and optionally a MIDI destination port by which you can send MIDI messages to it. In this case you only need to define the name of the MIDI device, as it shows up when you do code::MKtl.find::.
code::
( idInfo: "Ableton Push" )
::

If several devices of the same kind are connected, MKtl.find(\midi) will propose all of them as possible MKtls to choose, e.g. two nanoKontrol2s:

code::
MKtl.find(\midi);
//  post:
// Available MIDIMKtls:
// MKtl(name, filename);
		// *[ midi device, portname, uid]

MKtl('midi_0_iac_driver', 'midi_0_iac_driver');
		// [ "IAC Driver", "IAC Bus 1", -476939297 ]
MKtl('midi_1_nanokontrol2_nr_1', 'midi_1_nanokontrol2_nr_1');
		// [ "nanoKONTROL2", "SLIDER/KNOB", 1111689538 ]
MKtl('midi_2_nanokontrol2_nr_2', 'midi_2_nanokontrol2_nr_2');
		// [ "nanoKONTROL2", "SLIDER/KNOB", 2129951315 ]
::


Some MIDI devices use multiple MIDI ports, and MKtl treats these as separate devices for which you can make independent MKtls. E.g. the Steinberg CMC-PD or the QuNexus do this. For such devices, you can make separate descriptions for each port number, and you specify the port number in the description:
You then make a Dictionary of the code::idInfo:: with the field code::name:: with the name of the device (as it shows up after code::MKtl.find::), and then define the code::sourcePortIndex:: and/or the code::destinationPortIndex::; if either one is not specified, it takes the first one.

code::
// Steinberg CMC-PD or the QuNexus have 3 ports each,
// and their desc files know about them.
MKtlDesc.openFolder;
MKtlDesc.loadDescs("*qunexus*").do(_.openFile);
MKtlDesc.loadDescs("*cmc-pd*").do(_.openFile);
MKtlLookup.all.keys;

(
deviceName: "QuNexus",
...
)
// source/dest port numbers, you write:
(
idInfo: (
	deviceName: "QuNexus",
	sourcePortIndex: 0,
	destPortIndex: 0
),
...
)

::


section:: MIDI special messages

Some MIDI devices can be configured to special modes, eo one can e.g. set their LEDs to specific values, or generally, activate everything one wants to use. This is done by sending special messages (usually long and cryptic sysex). You can define these and other special messages in the code::specialMessages:: field of the device description.
For MIDI such a message has to be an Array of messages, and message begins with the type of MIDI message (as you would send it with link::Classes/MIDIOut::) and then the parameters to be sent.

For example: to configure the nanoKONTROL2 to a mode where one can access its LEDs from outside, one sends it a series of sysex messages. Some manufacturers do not document such technical details, and the messages in the nanoKONTROL2 desc file are simply exact reproductions of the messages the Korg KONTROL editor sends to the device when enabling external led control (which we found in a code base of someone else again). If your device responds special messages to tune its behavior, you can find out what they are  from the manual, by monitoring its configuration software, or get the info from someone who found this out and documented it (online, forums etc.)

code::
(
	specialMessages: (
	enableLEDControl:
	[
		[ \sysex, Int8Array[ 0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7 ] ],
		[ \sysex, Int8Array[ 0xF0, 0x42, 0x40, 0x00, 0x01, 0x13, 0x00, 0x1F, 0x12, 0x00, 0xF7] ],
		[ \sysex, Int8Array[ 0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7 ] ],
		//	... incomplete
])
)
::

If the device expects control messages, it would look like this:

code::
(
specialMessages: (
	activateTurboBoost:
[
	[ \control, 0, 3, 64 ], // message type name, chan, control, value
	// .. and others
])
)
::
