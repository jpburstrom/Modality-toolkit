title:: MKtl description files
summary:: describes the format for MKtl desc files and the entries in them.
categories:: Libraries>Modality
related:: Overviews/Modality, Classes/MKtl, Tutorials/How_to_create_a_description_file, Reference/Naming_conventions_in_element_descriptions

A description file contains detailed information about a controller, so it can be used to full advantage in Modality. Especially, precise information about each of its interaction elements (sliders, knobs, imus, and what-have-yous) help to create good performance setups very efficiently.

Evaluating the code in a desc file should return a link::Classes/Dictionary:: of a well-defined structure. Description files are located here:
code::
MKtlDesc.openFolder;
::

NOTE::
For a good overview on how a description file for your controller should look like, find a similar one that is already supported and look at its description file.
::

This document gives an overview on
list::
##link::#Filename conventions::
##link::#Semantic information::
##link::#Identifier naming convention::
##link::#Syntax::
::

section:: Filename convention

The filename should be of the following format:

code::
<vendor>-<device_name>_<optional_setup_naming>.desc.scd
::

where

list::
## code::<vendor>:: is lower-case name of vendor with spaces replaced by code::-::
## code::<device_name>:: is lower-case name of the device with spaces replaced by code::-::
This is both unique enough to identify devices, and allows linking to the modality website entry on each device.
## code::<optional_setup_naming>:: can be used to create multiple desc files for the same device, e.g. to support multiple ports (as e.g. the QuNexus keyboard), for special presets, such as making separate desc files for switchable hardware pages, or for personalized versions of desc files.
::

section:: Semantic and technical information

NOTE::
A description file is bound to a single protocol - currently one of \midi, \hid, and \osc. If there is a device that communicates on multiple protocols (e.g. the EMPHASIS::icon iCONTROLS::), its components have to be built from separate desc files and merged later on,
e.g. with CompMKtl.
::

subsection:: Top level

DEFINITIONLIST::

## deviceName | osx | linux [required]
|| For MIDI and HID, this is the device name as reported by the hardware or OS drivers.
## protocol [required]
|| The protocol used by the device
## deviceType [optional, but highly recommended]
|| Semantic description of what kind of device it is. This will make it easier to find another device that might easily replace it. For examples, do:
code::
MKtlDevice.deviceTypes;
MKtlDesc.loadDescs; MKtlDesc.deviceTypesUsed;

-> [ 'controller', 'djController', 'drumPad', 'drumpad', 'fader', 'faderbox', 'filterbank', 'gamepad', 'joystick', 'keyboard', 'launchpad', 'manta', 'mixer', 'mouse', 'multiController', 'phoneApp', 'push', 'ribbon' ]
::
## elementTypes [optional, but highly recommended]
|| Description of what kind of elements the device has. For example, code:: \fader, \button, \knob, \encoder, \joyAxis ... ::
## status [optional, but highly recommended]
|| A string describing the status of this description, e.g. code::"complete; tested; OSX, Linux"::, code::"incomplete; tested; OSX", ::code::"complete; tested; OSX;"::, code::"incomplete; untested;"::
## idInfo | osx | linux [required]
|| The info used to fully identify the device.
For HID devices, this is <productname>_<vendorname>.
For MIDI devices with single src and/or dest port, this is the same as the deviceName.
For multi-port MIDI devices, this should be a dictionary with entries for
(deviceName: <deviceName>,
sourcePortIndex: <index in MIDIClient.sources>,
destPortIndex: <index in MIDIClient.destinations>);
For OSC devices, this is a dictionary with information on the ipAdresses and ports used. (As NetAddresses may change, this often requires updating by hand. )

## elementsDesc [required]
|| A (usually hierarchical) dictionary describing the control elements of the device. These controls are called elements within the Modality toolkit.

## deviceInfo [optional]
|| A dictionary giving additional information on the device.

## collectives [optional]
|| Specific groups that are needed to send or receive data from the device. In particular these can be used for OSC devices.

## specs [optional]
|| A dictionary with specs in serialized notation, like code::(\key: [0, 144, \lin])::. These overwrite existing spec definitions locally for this description only: When an element has a symbol for a spec, this is looked up locally first, then in MKtl.globalSpecs, then in global Spec.specs.
::


subsection:: The description of a single element

A control element is a part of a controller (often for physical interaction, like a slider, knob, accelerometer etc. etc.) that does one or more of the following things:

list::
## creates and sends a one-dimensional stream of values when played,
## accepts a one-dimensional stream of values when sent from software.
::

For full details on single element description see also:
link::Reference/Naming_conventions_in_element_descriptions::

An element description is a dict (or event) containing these entries:
DEFINITIONLIST::

## midiMsgType
|| code::midiMsgType:: has to be present for elements belonging to a MIDI device.

## hidElementID | <hidUsage|hidUsagePage>
|| code::hidElementID:: or both code::hidUsage:: and code::hidUsagePage:: have to be present for elements belonging to an HID device.

## oscPath
|| code::oscPath:: has to be present for elements belonging to an OSC device, or it has to use code::ioType: \groupIn:: or code::ioType: \groupOut::

##  spec
|| The element code::\spec:: has to be present and is a symbol that, if called code::.asSpec:: upon, returns the (global) code::ControlSpec:: suitable for this element.
## \midiChan, \midiNum
|| Needed, if code::\midiType:: is part of the config string. The identifiers code::\bend, \touch, \program:: only need code::\midiChan:: to be specified.
::

	The 'elementsDesc' field is a dictionary that can contain other dictionaries or arrays, which will be used to build hierarchical groups of elements in the MKtl to be built from the description. At the leaves of this data structure must be a dictionary describing an element. Its most important keys are code:: \key, \shared, \elements::; \key defines a local lookup name for the element or group; shared defines properties shared between elements in this group, and \elements is an array of elements which again contain dictionaries describing elemnts or groups.
A typical structure would be:
	code::
(
// ...
elementsDesc: [ // the elementsDesc of the whole device
	(
		key: \top,  // name of this group,
					// all elements use cc and midichan 0
		shared: (midiChan: 0, midiMsgType: \control),

					// the elements descriptions:
		elements: [
					// a group of 2 sliders
			(
				key: \sl,   // group name
					// they share elementType and spec
				shared: (elementType: \slider, spec: \midiCC ),
				elements: [

					( key: \1, midiNum: 1 ),
					( key: \2, midiNum: 2 )
				]
			),
					// a group of 2 buttons
			(
				key: \bt,
					// they share elementType and spec
				shared: (elementType: \button, spec: \midiBut),
				elements: [
					( key: \1, midiNum: 1 ),
					( key: \2, midiNum: 2 )
				]
			)
		]
	)
]
)
::


	The 'specs' field contains a dictionary of specifications of controller ranges which the MKtl will use. An example:

code::
(
	\shaper:  [0, 128, \lin],
	\mover:   [1, 4096, \exp]
)
::

subsection:: deviceInfo

The deviceInfo is typically of the following form. All entries are optional.

code::
(
...
deviceInfo: (
    vendorURI: "http://vendor/product",
    manualURI: "http://manual.pdf",
    description: "Short sentence on what a great controller this is.",
    features: [
        "23 colorblinding pads",
        "42 invisible sliders",
    ],
    notes: "Make sure the device is in total-recall mode!",
    type: [\pad, \slider],
    hasScribble: false // see e.g. ableton push for a device that has one
),
description: ...
)
::

Examples for code::type:: are

list::
## code::pad::
## code::knob::
## code::encoder::
## code::mixer::
## code::fader::
## code::gamepad::
## code::joystick::
## code::pointer::
## code::keyboard::
::

Note that they are always written in singular.

section:: Identifier naming convention

Naming conventions for identifiers are:
list::
## code::kn:: for knobs,
## code::sl:: for sliders,
## code::bt:: for buttons,
## code::key:: for keys,
## code::pad:: for pads, etc. Elements with names or symbols on them should have that name, e.g. a play button should be called \play, a rewind button \rew, etc.
::

Naming conventions for type values are:
list::
## code::slider:: for sliders,
## code::knob:: for knobs,
## code::button:: for buttons,
## code::key:: for keys,
## code::pad:: for pads
## code::oscMessage:: for osc-messages (of collectives)
::

note::
The description file for the "Korg nanoKONTROL 2"
code::
korg-nanokontrol2.desc.scd
::
is a good example for element naming. All naming examples are taken from there.
::

Generally, element names should be as clear as possible, and reasonably short to allow for compact code. The main advantage of following the conventions is that similar elements across devices will have identical or at least simlar names, and thus allow substituting one device for a similar one with minimal code changes.

	Unnamed buttons should be called \bt, sliders \sl, knobs \kn, pads \pad, etc., and when they are physically in arrays, they should be given as, e.g.
code::
(
	key: \kn,
	shared: (\midiMsgType: \cc, \type: \knob, \midiChan: 0, \spec: \midiCC),
	elements: (16..23).collect { |i| (\midiNum: i) }
)
::
	When in rows and columns, these can be nested:
code::
(
	key: \bt,
	shared: (\midiMsgType: \cc, \type: \button, \midiChan: 0, \spec: \midiCC),
	elements: [(32..39),(48..55),(64..71)].collect { |xs|
		(
			elements: xs.collect { |i| (\midiNum: i) }
		)
	}
)
::

	Elements with names or symbols on them should be given that name,
	e.g.  a button name "play" or with a > sign on it  should be
	called \play or \playBt. in the nanoKontrol 2 file, such button names include transport buttons \rew, \fwd, \stop, \play, \rec,
	\cycle, track buttons \tleft, \tright, and marker buttons \mset, \mleft, \mright.

	When in doubt, consult files of devices with similar elements, and follow the naming schemes there.

section:: Grouping conventions:

Multiple elements of the same type, such as a bank of sliders, should be put in a single group, which can also be nested, as shown above.

Groups of elements which belong to a single physical control element (or otherwise belong together semantically) should be put in a single group. E.g. a gamepad thumbstick typically has an x-axis, a y-axis, and sometimes a hat switch, which should be in one group:

code::
	(key: \l,
		elements: [
			(key: \x, 'hidUsage': 48),
			(key: \y, 'hidUsage': 49)
		]
	)

// A group of two thumbsticks would be:

(
key: \joy,
shared: ('hidUsagePage': 1, 'elementType': 'joyAxis', 'ioType': 'in',
	spec: \cent1, mode: \center ),
elements: [
	(key: \l,
		elements: [
			(key: \x, 'hidUsage': 48),
			(key: \y, 'hidUsage': 49)
		]
	),
	(key: \r,
		elements: [
			(key: \x, 'hidUsage': 50),
			(key: \y, 'hidUsage': 53)
		]
	)
]
);
::

For MIDI noteOn and noteOff, two different patterns are possible, and there is a shortcut noteOnOff. E.g. for a button which sends noteOn and noteOff, the simplest use is :

code::
// the element description
d = ( key: \bt1, elementType: \button, midiMsgType: \noteOnOff, spec: \midiBut, midiNum: 12);

// for demonstration, make an MKtlElement from it, and give it an action
e = MKtlElement(\bt1, d);
e.action = { |el| el.value.postln; };
e.valueAction_(1); // noteOn
e.valueAction_(0); // noteOff

// determine inside the action whether it is on or off,
// as one does with gui buttons
e.action = { |el| if (el.value > 0) { "on" } { "off" }.postln };

e.valueAction_(1); // noteOn
e.valueAction_(0); // noteOff
::

While this is fine for simple buttons and pianokeys or pads, one loses use noteOff velocity information (which some keyboards send), and has the inconvenience of the if statement in the action.

So when independent on and off actions make sense, and when other elements should go into this group, one can make them separately:

code::
// description of a pad with noteOn, noteOff and poly touch:
d = (
	\pad1,
	shared: (midiChan: 0, midiNum: 45),
	elements: [
		(key: \on, \midiMsgType: \noteOn, spec: \midiVel),
		(key: \off, \midiMsgType: \noteOff, spec: \midiVel),
		(key: \touch, \midiMsgType: \polyTouch, spec: \midiCC)
	]
);
::
This creates a semantically clear group, and generates separate elements
with independent actions for each message type.
the noteOn action could be used to start a synth,
touch to update one of its parameters while alive,
and noteOff (using noteOff velocity) to end this synth.


section:: Syntax

NOTE:: ABNF notation needs update.::
The syntax for the description file as agreed on by the modalityTeam on April, 7th 2014
described in Augmented Backus–Naur Form (with code::/:: switched to code::|:: ) (see link::https://en.wikipedia.org/wiki/ABNF::).

NOTE::For an example for the description file syntax, see link::Tutorials/How_to_create_a_description_file::.::

NOTE::
The actual description files used by Modality often don't conform to this syntax because they use SuperCollider code to algorithmically generate the dictionary. In any case calling code::.asCompileString:: on the dictionary should generate a string which conforms to the syntax above.
::

TELETYPE::
descFile                    = "( protocol: " protocol ", device: " string ", description:" description [", infoMessage:" string] ")"
    protocol                = "\hid" | "\midi"
    idInfo                  = ("idInfo :" string) | ("osx : (idInfo: "string ") " [", linux: (idInfo: "string ")" ] ) | ("linux: (idInfo: "string ") " [", osx: (idInfo:" string ")" ] )
    description             = hidDict | midiDict
	collectives             = hidDict | midiDict
    midiDict                = "(" symbol ":" midiNode [", " *(symbol ":" midiNode) ] ")"
        midiArray           = "[" midiNode [", " *midiNode ] "]"
        midiNode            = midiDict | midiArray | midiElem
    hidDict                 = "(" symbol ":" hidNode [", " *(symbol ":" hidNode) ] ")"
        hidArray            = "[" hidNode [", " *hidNode ] "]"
        hidNode             = hidDict | hidArray | hidElem
midiElem                    = midiElemFull | midiElemOnlyChan
    midiElemFull            = "( midiMsgType:" midiMsgTypeFull ", midiChan:" int ", midiNum:" int ", spec:" symbol ", type:" type [", ioType:" ioType] [", mode:" mode] ")"
        midiMsgTypeFull     = "\noteOnOff" | "\noteOn" | "\noteOff" | "\cc" | "\polytouch"
    midiElemOnlyChan        = "( midiMsgType:" midiMsgTypeOnlyChan ", midiChan:" int ", spec:" symbol ", type:" type [", ioType:" ioType] [", mode:" mode] ")"
        midiMsgTypeOnlyChan = "\bend" | "\touch"  | "\program"
hidElem                     = "( \hidUsage:" int ", \hidUsagePage: " int ", spec:" symbol ", type:" type [", ioType:" ioType] [", mode:" mode] ")"
    type                    = "\knob" | "\button" | "\key" | "\slider" | "\chantouch" | "\polytouch" | "\joyaxis" | "\hatswitch" | "\encoder" | "\pad"
    mode                    = "\one-shot" | "\push" | "\minimum" | "\center" | "\toggle"
    ioType                  = "\in" | "\out" | "\inout"

int                         = digitFromOne *digitFromZero
    digitFromZero           = "0" | digitFromOne
        digitFromOne        = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
string                      = "\"" *char "\""
char                        = %x01-7F

::
