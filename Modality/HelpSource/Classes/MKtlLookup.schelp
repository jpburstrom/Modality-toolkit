TITLE:: MKtlLookup
summary:: unify lookup for MKtl devices
categories:: Libraries/Modality
related:: Classes/MKtl,  Classes/MKtlDesc, Classes/MKtlDevice

DESCRIPTION::
MKtlLookup provides a single dictionary with unique lookup names for all hardware/network devices found or declared, so they can be used with MKtls.
The names are intentionally long to be both unique and descriptive of the source. short nicknames can and should be given in the MKtl creation:
code::
MKtl(\nk2, 'midi_0_nanokontrol2');
MKtl('nk2').listenTo( 0 ).sendTo(0);
MKtl('nk2').trace;


MKtl(\nk2b, 'midi_0_nanokontrol2');
MKtl('nk2b').listenTo( 1 ).sendTo(1);
MKtl('nk2b').trace;
MKtl('nk2b').elementAt(\play).value_(1);


MKtl.find // does these find operations:
	// HID.findAvailable;
	// MIDIClient.init;
	// MKtlLookup.addAllHID;
	// MKtlLookup.addAllMIDI;

// depending on the kind of device,
MKtlLookup.names.printcsAll;

// add some osc devices by hand:
MKtlLookup.addOSC(NetAddr.localAddr, \sclang);
MKtlLookup.addOSC(s.addr, "server_%".format(s.name).asSymbol).put(\server, s);
MKtlLookup.addOSC(NetAddr("192.168.94.23", 1234), \gyrosc);

MKtlLookup.names.printcsAll;

// list all midi devices:
MKtlLookup.allFor(\midi);

// for each device found, MKtlLookup has a dict with all the useful info
// that is known about the device at this point.

// E.g. the dict for a midi device will contain :
MKtlLookup.allFor(\midi).choose.postcs;

( 'idInfo': nanoKONTROL2,   // name of the device as it registers to the OS
'protocol': midi,           // the protocol it uses
			// the endpoints that belong to it, src and dest:
'srcDevice': MIDIEndPoint("nanoKONTROL2", "SLIDER/KNOB", 1140916328),
'destDevice': MIDIEndPoint("nanoKONTROL2", "CTRL", -1609859973),
			// the unique name under which the info is stored
'lookupName': midi_0_nanokontrol2,
			// name of the matching description file if there is one:
'filename': korg-nanokontrol2,
			// all the endpoints that belong to it:
'deviceInfo': [ MIDIEndPoint("nanoKONTROL2", "SLIDER/KNOB", 1140916328), MIDIEndPoint("nanoKONTROL2", "CTRL", -1609859973) ] )
::

NOTE:: Currently, all endpoints found for the same device name are registered
as one info dict. For most single-in, single-out devices this works perfectly.
When multiple devices of the same kind are present (e.g. 2 midifader boxes)
::

CLASSMETHODS::

METHOD:: all
the lookup dictionary

private:: initClass

METHOD:: addHID
add a HIDInfo by as found by index in HID.available

METHOD:: addAllHID
add all HIDINfos currently found in HID.available

METHOD:: addSerial

METHOD:: addMIDI
add a MIDIEndpoint as found by index in MIDIClient.sources or .destinations.
type (\src or \dest) tells MKtlLookup whether it is in sources or .destinations.

METHOD:: addAllMIDI
add all MIDIEndpoints currently found in MIDIClient sources or destinations. Happens automatically in MIDIMktlDevice.find.

METHOD:: midiAt
find a MIDIEndpoint by type and index

METHOD:: midiAt

METHOD:: addOSC
add an OSC source or dest. as these are not globally represented, make them by hand,
with sendAddr, replyAddr, and (given) name.

METHOD:: findByIDInfo

code::
// MKtl.find detects installed IAC Driver
MKtl.find(\midi);
// finds it directly by name
MKtlLookup.findByIDInfo("IAC Driver");
// also when given in a dict:
MKtlLookup.findByIDInfo((deviceName: "IAC Driver"));
// and even when the dict says sourcePortIndex 0,
// and the lookup info has no sourcePortIndex (i.e. it is a single port
MKtlLookup.findByIDInfo((deviceName: "IAC Driver", sourcePortIndex: 0 ));
::

INSTANCEMETHODS::

none, MKtlLookup is a Singleton.

