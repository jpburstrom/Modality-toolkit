// 2016, Till Bovermann


(
q = ();
(
MKtlDesc.platformSpecific = false;
q.imgPath = "/localvol/modality/ModalityTeam.github.io/img/controllers";
q.scribblePath = "/localvol/modality/ModalityTeam.github.io/img/controller.scribble";
q.outPath = "/localvol/modality/ModalityTeam.github.io/_posts";

// paths to create links to github edit pages.
// this only works for having one basepath atm.
q.basepath = MKtlDesc.descFolders.first;
q.descEditBasepath = "https://github.com/ModalityTeam/Modality-toolkit/tree/master/Modality/MKtlDescriptions";

q.makeDict = {|q, desc|
	var outDict = ();
	var fullDesc = desc.fullDesc;

	fullDesc.notNil.if({
		var deviceInfo = fullDesc.deviceInfo;

		outDict.fileName = desc.name;
		outDict.hwInterface = desc.protocol.asString;
		outDict.type      = fullDesc.deviceType.asString;
		outDict.status = fullDesc.status;
		outDict.testCode= desc.testCode;

		outDict.hasScribble = File.exists("%/%.scribble.pdf".format(
			q.scribblePath, outDict.fileName)
		);
		outDict.hasScribble.if{
			outDict.scribbleFilename = "%.scribble.pdf".format(
			outDict.fileName);
		};

		outDict.hasScribble.not.if{outDict.hasScribble = nil};


		outDict.imageType = [\png, \jpg].detect{|type|
			File.exists("%/%.%".format(q.imgPath, outDict.fileName, type))
		};
		outDict.imageType.notNil.if{
			outDict.imageFilename = "%.%".format(outDict.fileName, outDict.imageType);
		};




		outDict.descEditPath = "%/%".format(q.descEditBasepath, desc.path.replace(q.basepath, ""););






		deviceInfo.notNil.if({
			outDict.vendorURI = deviceInfo.vendorURI;
			outDict.manual    = deviceInfo.manualURI;
			outDict.description = deviceInfo.description ?? {"A % % device.".format(outDict.type, outDict.hwInterface)};
			outDict.features = deviceInfo.features;
			outDict.notes = deviceInfo.notes;

			outDict.title = (deviceInfo.longName ?? {outDict.fileName.asString.tr($-, $ )}).asString;
		}, {
			outDict.title = outDict.fileName.asString.tr($-, $ )
		})
	}, {
		"% is not a valid desc".format(desc.name).warn;
		outDict = nil;
	});

	(fullDesc.portName.notNil && {fullDesc.modeName.notNil}).if({
		outDict.title = "% (%, %)".format(outDict.title, fullDesc.portName, fullDesc.modeName);
	}, {
		(fullDesc.portName.notNil).if{
			outDict.title = "% (%)".format(outDict.title, fullDesc.portName);
		};
		(fullDesc.modeName.notNil).if{
			outDict.title = "% (%)".format(outDict.title, fullDesc.modeName);
		};
	});

	// remove empty strings
	outDict.keys.do{|key|
		(outDict[key] == "").if{
			outDict[key] = nil;
		}
	};

	outDict;
};



q.makeMarkdownDoc = {|q, dict, path|
	var string, file;


	string =
	"---\nlayout: controllers\n"
	++ //single line
	[
		\title,
		\hwInterface,
		\vendorURI,
		\manual,
		\type,
		\imageFilename,
		// \hasScribble,
		\descEditPath,
		\scribbleFilename
	].inject("", {|last, key|
		var val = dict[key];
		val.notNil.if({
			last ++ "%: %\n".format(
				key,
				dict[key].asCompileString
			);
		}, {
			last
		})

	})
	++ // multiline string
	[
		\notes,
		\description,
	].inject("", {|last, key|
		var val = dict[key];
		val.notNil.if({
			last ++ "%: |\n%\n".format(
				key,
				val.split($\n).inject("", {|last, line|
					last ++ "  %\n\n".format(line);
				})
			);
		}, {
			last
		})

	})
	++ // itemise as array
	[
		\features,
	].inject("", {|last, key|
		var val = dict[key];
		val.notNil.if({
			last ++ "%: |\n%\n".format(
				key,
				val.inject("", {|last, line|
					last ++ "  + %\n".format(line);
				})
			);
		}, {
			last
		})
	})
	++ // definition from dict
	[
		\status,
	].inject("", {|last, key|
		var val = dict[key];
		val.notNil.if({
			last ++ "%: |\n%\n".format(
				key,
				val.asAssociations.inject("", {|last, ass|
					last ++ "  + *%* -- %\n".format(ass.key, ass.value);
				})
			);
		}, {
			last
		})
	})
	++ "---\n"
	++	"{% comment %}"
	++ "This file was autogenerated on %. Please edit corresponding desc-file.".format(Date.getDate.asString)
	++ "{% endcomment %}";

	file = File("%/2015-05-22-%.md".format(path, dict.fileName), "w");
	file.write(string);
	file.close;
	// Document("%.md".format(dict.fileName), string)
};

);



(
q.all = MKtlDesc.loadDescs;
q.all.do{|desc|
	var dict;
	desc.name.postln;
	dict = q.makeDict(desc);
	// dict.title.postln;
	dict.notNil.if{
		q.makeMarkdownDoc(dict, q.outPath)
	}
}
)
)



/////////////// tests etc. /////////////////////

q.all.first.fullDesc.portName

(
var desc = q.all.first;
var dict;


dict = q.makeDict(desc);
dict.status
)


// q.basepath = "/Users/tboverma/Library/Application Support/SuperCollider/downloaded-quarks/Modality-toolkit/Modality/MKtlDescriptions"

q.all.first.path.replace(q.basepath, "")

m = MKtlDesc.loadDescs("*qu*").first;

m.path.replace(q.basepath, "");


m.deviceFilename

m.descExt


q.all.first


MKtlDesc